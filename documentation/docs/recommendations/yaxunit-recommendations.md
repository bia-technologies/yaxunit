---
sidebar_position: 3
---

# Рекомендации по использованию YAxUnit

Помимо [общих рекомендаций](common-recommendations.md), при работе с YAxUnit важно следовать следующим принципам:

### Организация тестовых модулей

* **Модуль тестового набора должен соответствовать тестируемому объекту решения** — это упрощает навигацию и понимание структуры тестов

  :::bad
  ```
  Тесты1
  ТестыИванов
  ТестыЯнварь2025
  ТестыИнцидентов
  ```
  :::

  :::good
  ```
  Док_РасчетЗарплаты
  Док_Сотрудники
  Обр_РасчетПремий
  ```
  :::

* **Соблюдайте [схему наименования модулей](../getting-started/structure.md#схема-наименования-модулей)** — единый подход к именованию упрощает поиск нужных тестов и добавление новых

  :::bad
  ```
  Тесты_СчетНаОплату
  ТестыДокументаСчетНаОплату
  ЗагрузкиДанных
  Проверка_Взаиморасчеты
  ```
  :::

  :::good
  ```
  Док_СчетНаОплату
  Обр_ЗагрузкиДанных_МО
  РН_Продажи_ММ
  ```
  :::

* **Именование тестов:** используйте понятные имена тестов, которые отражают проверяемый сценарий — например, `Тест_РасчетНДСПриНулевойСумме` лучше, чем `Тест_РасчетНДС1`

  :::bad
  ```bsl
  // Неинформативные имена тестов
  Процедура ТестРасчета1() Экспорт
    // Тест расчета скидки
  КонецПроцедуры
  
  Процедура ТестРасчета2() Экспорт
    // Тест расчета бонусов
  КонецПроцедуры
  
  Процедура ТестРасчета3() Экспорт
    // Тест расчета итогов
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Понятные имена тестов
  Процедура Тест_РасчетСкидкиПриСуммеЗаказаБольше10000() Экспорт
    // Тест расчета скидки
  КонецПроцедуры
  
  Процедура Тест_РасчетБонусовПриПервомЗаказе() Экспорт
    // Тест расчета бонусов
  КонецПроцедуры
  
  Процедура Тест_РасчетИтоговСУчетомСкидкиИБонусов() Экспорт
    // Тест расчета итогов
  КонецПроцедуры
  ```
  :::

* **Для каждого проверяемого объекта создавайте отдельный модуль** — это обеспечивает изолированность и упрощает поддержку

  :::bad
  ```
  // Один общий модуль для всех документов подсистемы
  Тесты_ДокументыЗакупок
  ```
  :::

  :::good
  ```
  Док_ЗаказПоставщику
  Док_ПоступлениеТоваров
  Док_СчетНаОплатуПоставщика
  ```
  :::

* **Используйте встроенные инструменты фреймворка** — применяйте ЮТУтверждения для проверок и конструкторы для создания тестовых данных, это сделает тесты более читаемыми и надежными

  :::bad
  ```bsl
  Если СуммаДокумента <> 1000 Тогда
    ВызватьИсключение "Неверная сумма документа";
  КонецЕсли;
  ```
  :::

  :::good
  ```bsl
  ЮТест.ОжидаетЧто(СуммаДокумента, "Сумма документа")
    .Равно(1000, "Сумма документа рассчитана неверно");
  ```
  :::

### Изоляция тестовой среды

* **Тестовая база:** запускайте тесты на изолированной «пустышке» или демо-базе без реальных данных — это исключит побочные эффекты и обеспечит предсказуемость результатов

  :::bad
  ```bsl
  // Запуск тестов на рабочей базе с реальными данными
  Клиент = Справочники.Контрагенты.НайтиПоНаименованию("ООО Рога и копыта");
  РаботаСДаннымиТеста = ЗарегистрироватьДанныеДляУдаления(Клиент);
  ```
  :::

  :::good
  ```bsl
  // Подготовка изолированных тестовых данных
  Клиент = ЮТест.Данные().КонструкторОбъекта("Справочник.Контрагенты")
    .ФикцияОбязательныхПолей()
    .Установить("Наименование", "Тестовый контрагент")
    .Записать();
    
  РаботаСДаннымиТеста = ЗарегистрироватьДанныеДляУдаления(Клиент.Ссылка);
  ```
  :::

* **Очистка после тестов:** удаляйте созданные тестовые данные после выполнения тестов — используйте механизмы ВТранзакции и УдалениеТестовыхДанных, чтобы не оставлять «мусор»

  :::bad
  ```bsl
  // Тестовые данные остаются в базе
  Процедура Тест_СозданиеДокумента() Экспорт
    Док = Документы.РасходнаяНакладная.СоздатьДокумент();
    Док.Дата = ТекущаяДата();
    Док.Записать();
    // Нет очистки
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  Процедура ИсполняемыеСценарии() Экспорт
    
    ЮТТесты.ВТранзакции()
      .ДобавитьТест("Тест_СозданиеДокумента")
      .ДобавитьТест("Тест_СозданиеДокумента2");

  КонецПроцедуры

  // Использование транзакции для автоматической очистки
  Процедура Тест_СозданиеДокумента() Экспорт
    Док = ЮТест.Данные().КонструкторОбъекта("Документ.РасходнаяНакладная")
      .ФикцияОбязательныхПолей()
      .Записать(Истина);
      
    ЮТест.ОжидаетЧто(Док, "Созданный документ")
      .Заполнено()
      .ИмеетТип("ДокументСсылка.РасходнаяНакладная");
  КонецПроцедуры
  ```
  :::

* **Моки и стабы:** подменяйте внешние сервисы или сложные компоненты на упрощенные реализации — это избавит ваши тесты от зависимости от внешних систем, сети и делает их более стабильными

  :::bad
  ```bsl
  // Прямой вызов внешнего сервиса
  Функция Тест_ЗапросКСервису()
    Результат = Интеграция.ВыполнитьЗапроса(АдресРусурса);
    ЮТест.ОжидаетЧто(Результат.Успех).ЭтоИстина();
  КонецФункции
  ```
  :::

  :::good
  ```bsl
  // Использование заглушки вместо реального сервиса
  Функция Тест_ЗапросКСервису()
    Ответ = Новый Структура("Успех", Истина);
    // Подмена реального сервиса
    Мокито.Обучение(Интеграция)
      .Когда("ВыполнитьЗапроса").Вернуть(Ответ)
      .Прогон();
    
    Результат = Интеграция.ВыполнитьЗапроса(АдресРусурса);
    
    ЮТест.ОжидаетЧто(Результат, "Результат запроса")
      .Свойство("Успех").ЭтоИстина();
      
    Мокито.Проверить(Интеграция)
      .КоличествоВызовов("ВыполнитьЗапроса")
        .Равно(1, "Метод сервиса должен быть вызван один раз");
  КонецФункции
  ```
  :::

### Принципы написания тестов

* **Атомарность:** один тест — один сценарий — например, вместо общего теста на проводки документа создайте отдельные тесты для каждого типа проводки

  :::bad
  ```bsl
  // Один тест проверяет всю функциональность документа
  Процедура Тест_ДокументРеализация() Экспорт
    // Создание документа
    Док = СоздатьДокумент();
    
    // Проверка заполнения шапки
    ЮТест.ОжидаетЧто(Док.Контрагент).Заполнено();
    ЮТест.ОжидаетЧто(Док.КонтДоговоррагент).Заполнено();
    
    // Проверка табличной части
    ЮТест.ОжидаетЧто(Док.Товары).ИмеетДлину(1);
    
    // Проверка проведения
    Док.Записать(РежимЗаписиДокумента.Проведение);
    
    // Проверка движений по регистру взаиморасчетов
    ЮТест.ОжидаетЧто(Док.Движения.Взаиморасчеты).ИмеетДлину(1);
    
    // Проверка движений по регистру товаров
    ЮТест.ОжидаетЧто(Док.Движения.ТоварыНаСкладах).ИмеетДлину(1);
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Отдельные тесты для разных аспектов документа
  Процедура Тест_ЗаполнениеШапкиДокументаРеализация() Экспорт
    Док = ЮТест.Данные().КонструкторОбъекта("Документ.РеализацияТоваров")
      .ФикцияОбязательныхПолей()
      .Записать(Истина);
      
    ЮТест.ОжидаетЧто(Док, "Созданный документ")
      .Свойство("Контрагент").Заполнено()
      .Свойство("Договор").Заполнено();
  КонецПроцедуры
  
  Процедура Тест_ФормированиеДвиженийПоВзаиморасчетам() Экспорт
    Док = ЮТест.Данные().КонструкторОбъекта("Документ.РеализацияТоваров")
      .ФикцияОбязательныхПолей()
      .Записать(РежимЗаписиДокумента.Проведение);
      
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Движения.Взаиморасчеты").ИмеетДлину(1)
      .Свойство("Движения.Взаиморасчеты[0].Сумма").Равно(Док.СуммаДокумента);
  КонецПроцедуры
  
  Процедура Тест_СписаниеТоваровСоСклада() Экспорт
    Док = ЮТест.Данные().КонструкторОбъекта("Документ.РеализацияТоваров")
      .ФикцияОбязательныхПолей()
      .Записать(РежимЗаписиДокумента.Проведение);
      
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Движения.ТоварыНаСкладах").ИмеетДлину(1)
      .Свойство("Движения.ТоварыНаСкладах[0].ВидДвижения").Равно(ВидДвиженияНакопления.Расход);
  КонецПроцедуры
  ```
  :::

* **Простота:** избегайте условных конструкций и ветвления в тестах — условия (Если) усложняют понимание теста; если нужны разные сценарии, лучше разбейте их на отдельные методы

  :::bad
  ```bsl
  // Сложная логика внутри теста с условиями
  Процедура Тест_РасчетСкидки() Экспорт
    Клиент = СоздатьТестовогоКлиента();
    Заказ = СоздатьТестовыйЗаказ(Клиент);
    
    Если Клиент.КатегорияВИП Тогда
      // Проверка расчета VIP-скидки
      ЮТест.ОжидаетЧто(Заказ.Скидка).Равно(15);
    ИначеЕсли ТекущаяДата() > НачалоМесяца(ТекущаяДата()) Тогда
      // Проверка скидки начала месяца
      ЮТест.ОжидаетЧто(Заказ.Скидка).Равно(10);
    Иначе
      // Проверка обычной скидки
      ЮТест.ОжидаетЧто(Заказ.Скидка).Равно(5);
    КонецЕсли;
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Разделение на отдельные тесты без условий
  Процедура Тест_РасчетСкидкиДляVIPКлиента() Экспорт
    Клиент = ЮТест.Данные().КонструкторОбъекта("Справочник.Контрагенты")
      .ФикцияОбязательныхПолей()
      .Установить("КатегорияВИП", Истина)
      .Записать(Истина);
      
    Заказ = ЮТест.Данные().КонструкторОбъекта("Документ.ЗаказКлиента")
      .ФикцияОбязательныхПолей()
      .Установить("Контрагент", Клиент)
      .Записать(Истина);
      
    ЮТест.ОжидаетЧто(Заказ, "Заказ VIP клиента")
      .Свойство("Скидка").Равно(15);
  КонецПроцедуры
  
  Процедура Тест_РасчетСкидкиНачалаМесяца() Экспорт
    Клиент = ЮТест.Данные().КонструкторОбъекта("Справочник.Контрагенты")
      .ФикцияОбязательныхПолей()
      .Установить("КатегорияВИП", Ложь)
      .Записать(Истина);
      
    Заказ = ЮТест.Данные().КонструкторОбъекта("Документ.ЗаказКлиента")
      .ФикцияОбязательныхПолей()
      .Установить("Контрагент", Клиент)
      .Установить("Дата", НачалоМесяца(ТекущаяДата()))
      .Записать(Истина);
      
    ЮТест.ОжидаетЧто(Заказ, "Заказ начала месяца")
      .Свойство("Скидка").Равно(10);
  КонецПроцедуры
  
  Процедура Тест_РасчетСтандартнойСкидки() Экспорт
    Клиент = ЮТест.Данные().КонструкторОбъекта("Справочник.Контрагенты")
      .ФикцияОбязательныхПолей()
      .Установить("КатегорияВИП", Ложь)
      .Записать(Истина);
      
    Заказ = ЮТест.Данные().КонструкторОбъекта("Документ.ЗаказКлиента")
      .ФикцияОбязательныхПолей()
      .Установить("Контрагент", Клиент)
      .Записать(Истина);
      
    ЮТест.ОжидаетЧто(Заказ, "Стандартный заказ")
      .Свойство("Скидка").Равно(5);
  КонецПроцедуры
  ```
  :::

* **Параметризация:** используйте один тестовый метод с разными входными данными — это позволяет избежать дублирования кода при проверке однотипных сценариев

  :::bad
  ```bsl
  // Повторение одинаковой логики в разных тестах
  Процедура Тест_РасчетНДС18() Экспорт
    Сумма = 100;
    НДС = УчетныйМодуль.РассчитатьНДС(Сумма, 18);
    ЮТест.ОжидаетЧто(НДС, "НДС по ставке 18%").Равно(18);
  КонецПроцедуры
  
  Процедура Тест_РасчетНДС20() Экспорт
    Сумма = 100;
    НДС = УчетныйМодуль.РассчитатьНДС(Сумма, 20);
    ЮТест.ОжидаетЧто(НДС, "НДС по ставке 20%").Равно(20);
  КонецПроцедуры
  
  Процедура Тест_РасчетНДС10() Экспорт
    Сумма = 100;
    НДС = УчетныйМодуль.РассчитатьНДС(Сумма, 10);
    ЮТест.ОжидаетЧто(НДС, "НДС по ставке 10%").Равно(10);
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Использование параметризации
  Процедура ИсполняемыеСценарии() Экспорт
    ЮТТесты
      .ДобавитьТест("Тест_РасчетНДС")
        .СПараметрами("Сумма, СтавкаНДС, ОжидаемыйНДС", 100, 18, 18)
        .СПараметрами("Сумма, СтавкаНДС, ОжидаемыйНДС", 100, 20, 20)
        .СПараметрами("Сумма, СтавкаНДС, ОжидаемыйНДС", 100, 10, 10)
        .СПараметрами("Сумма, СтавкаНДС, ОжидаемыйНДС", 50, 20, 10);
  КонецПроцедуры
  
  Процедура Тест_РасчетНДС(Сумма, СтавкаНДС, ОжидаемыйНДС) Экспорт
    НДС = УчетныйМодуль.РассчитатьНДС(Сумма, СтавкаНДС);
    
    ЮТест.ОжидаетЧто(НДС, "Рассчитанный НДС")
      .Равно(ОжидаемыйНДС, "Неверный расчет НДС для суммы " + Сумма + " и ставки " + СтавкаНДС);
  КонецПроцедуры
  ```
  :::

* **Баланс в рефакторинге:** выделяйте повторяющиеся действия в отдельные методы (например, создание тестового документа), но избегайте излишней абстракции — если вспомогательный метод становится сложным, лучше упростите его

  :::bad
  ```bsl
  // Дублирование кода в каждом тесте
  Процедура Тест_ПроведениеДокументаСПустойТабличнойЧастью() Экспорт
    Док = Документы.ПриходнаяНакладная.СоздатьДокумент();
    Док.Дата = ТекущаяДата();
    Док.Контрагент = Справочники.Контрагенты.НайтиПоНаименованию("Тестовый");
    Док.Договор = Справочники.ДоговорыКонтрагентов.НайтиПоКоду("1");
    Док.Записать(РежимЗаписиДокумента.Проведение);
    
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Проведен").ЭтоИстина();
  КонецПроцедуры

  Процедура Тест_ПроведениеДокумента() Экспорт
    Док = Документы.ПриходнаяНакладная.СоздатьДокумент();
    Док.Дата = ТекущаяДата();
    Док.Контрагент = Справочники.Контрагенты.НайтиПоНаименованию("Тестовый");
    Док.Договор = Справочники.ДоговорыКонтрагентов.НайтиПоКоду("1");
    СтрТЧ = Док.Товары.Добавить();
    СтрТЧ.Номенклатура = Справочники.Номенклатура.НайтиПоКоду("1");
    СтрТЧ.Количество = 10;
    СтрТЧ.Цена = 100;
    СтрТЧ.Сумма = 1000;
    Док.Записать(РежимЗаписиДокумента.Проведение);
    
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Проведен").ЭтоИстина();
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Понятный и простой вспомогательный метод
  Функция СоздатьПриходнуюНакладную()
    Возврат ЮТест.Данные().КонструкторОбъекта("Документ.ПриходнаяНакладная")
      .ФикцияОбязательныхПолей();
    ;
  КонецФункции
  
  Процедура ДобавитьТестовуюНоменклатуру(Конструктор) Экспорт
    Конструктор
      .ДобавитьСтроку()
        .Установить("Номенклатура", Справочники.Номенклатура.НайтиПоКоду("1"))
        .Установить("Количество", 10)
        .Установить("Цена", 100)
        .Установить("Сумма", 1000)
    ;
  КонецПроцедуры
  
  // Использование в тестах
  Процедура Тест_ПроведениеДокументаСПустойТабличнойЧастью() Экспорт
    Конструктор = СоздатьПриходнуюНакладную();
    Док = Конструктор.Провести();
    
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Проведен").ЭтоИстина();
  КонецПроцедуры

  Процедура Тест_ПроведениеДокумента() Экспорт
    Конструктор = СоздатьПриходнуюНакладную();
    ДобавитьТестовуюНоменклатуру(Конструктор.ТабличнаяЧасть("Товары"));
    Док = Конструктор.Провести();
    
    ЮТест.ОжидаетЧто(Док, "Проведенный документ")
      .Свойство("Проведен").ЭтоИстина();
  КонецПроцедуры
  ```
  :::

* **Расширенное покрытие:** тестируйте не только успешные сценарии, но и обработку ошибок, а также различные граничные значения — минимальные/максимальные числа, отрицательные числа, пустые строки, нулевые даты, пустые ссылки

  :::bad
  ```bsl
  // Тестирование только "счастливого пути"
  Процедура Тест_ВычислениеСтажа() Экспорт
    ДатаПриема = Дата(2010, 1, 1);
    Стаж = КадровыйУчет.РассчитатьСтаж(ДатаПриема, ТекущаяДата());
    
    ЮТест.ОжидаетЧто(Стаж).Больше(0);
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Набор тестов с разными граничными случаями
  Процедура Тест_ВычислениеСтажаСтандартныйСлучай() Экспорт
    ДатаПриема = Дата(2010, 1, 1);
    ДатаРасчета = Дата(2020, 1, 1);
    Стаж = КадровыйУчет.РассчитатьСтаж(ДатаПриема, ДатаРасчета);
    
    ЮТест.ОжидаетЧто(Стаж, "Рассчитанный стаж")
      .Равно(10, "Стаж должен быть равен 10 годам");
  КонецПроцедуры
  
  Процедура Тест_ВычислениеСтажаПриНулевойДате() Экспорт
    ДатаПриема = '00010101';
    ДатаРасчета = ТекущаяДата();
    
    ЮТест.ОжидаетЧто(КадровыйУчет)
      .Метод("РассчитатьСтаж").Параметр(ДатаПриема).Параметр(ДатаРасчета)
      .ВыбрасываетИсключение("Нельзя рассчитать стаж для нулевой даты");
  КонецПроцедуры
  
  Процедура Тест_ВычислениеСтажаПриДатеПриемаБольшеТекущей() Экспорт
    ДатаПриема = ДобавитьМесяц(ТекущаяДата(), 1);
    ДатаРасчета = ТекущаяДата();
    
    ЮТест.ОжидаетЧто(КадровыйУчет)
      .Метод("РассчитатьСтаж").Параметр(ДатаПриема).Параметр(ДатаРасчета)
      .ВыбрасываетИсключение("Дата приема не может быть больше текущей даты");
  КонецПроцедуры
  
  Процедура Тест_ВычислениеСтажаПриОдинаковыхДатах() Экспорт
    ДатаОдинаковая = ТекущаяДата();
    Стаж = КадровыйУчет.РассчитатьСтаж(ДатаОдинаковая, ДатаОдинаковая);
    
    ЮТест.ОжидаетЧто(Стаж, "Стаж при одинаковых датах")
      .Равно(0, "Стаж должен быть равен 0 при одинаковых датах");
  КонецПроцедуры
  ```
  :::

* **Документирование:** добавляйте комментарии, поясняющие назначение каждого теста — это поможет другим разработчикам понять его цель и логику

  :::bad
  ```bsl
  Процедура Тест_МетодРасчетаСкидки() Экспорт
    // Нет комментариев и пояснений
    Заказ = СоздатьТестовыйЗаказ();
    Скидка = Заказ.ПолучитьСкидку();
    ЮТест.ОжидаетЧто(Скидка).Равно(5);
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Тест проверяет расчет стандартной 5% скидки для обычного клиента при заказе до 10000 руб.
  // Важно: скидка применяется только для товаров не участвующих в распродаже
  Процедура Тест_РасчетСтандартнойСкидкиДляОбычногоКлиентаПриНебольшомЗаказе() Экспорт
    Заказ = СоздатьТестовыйЗаказ(5000, "Обычный", Ложь);
    Скидка = Заказ.ПолучитьСкидку();
    
    ЮТест.ОжидаетЧто(Скидка)
      .Равно(5, "Стандартная скидка 5% не применилась для обычного клиента");
  КонецПроцедуры
  ```
  :::

* **Независимость:** каждый тест должен работать изолированно от других — не рассчитывайте, что один тест подготовит данные для другого

  :::bad
  ```bsl
  // Тесты зависят от порядка выполнения и общих данных
  Процедура Тест_СозданиеДокумента() Экспорт
    ТестовыйДокумент = Документы.ЗаказКлиента.СоздатьДокумент();
    ТестовыйДокумент.Номер = "000001";
    ТестовыйДокумент.Дата = ТекущаяДата();
    ТестовыйДокумент.Записать();
    
    ЮТест.ОжидаетЧто(ТестовыйДокумент.Ссылка, "Ссылка документа").НеРавно(Неопределено);
  КонецПроцедуры

  Процедура Тест_ПроведениеДокумента() Экспорт
    // Используем документ из предыдущего теста
    ТестовыйДокумент = Документы.ЗаказКлиента.НайтиПоНомеру("000001");
    ТестовыйДокумент.Записать(РежимЗаписиДокумента.Проведение);
    
    ЮТест.ОжидаетЧто(ТестовыйДокумент.Проведен, "Документ проведен").ЭтоИстина();
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Каждый тест независимо создает и настраивает данные
  Процедура Тест_СозданиеДокумента() Экспорт
    Документ = Документы.ЗаказКлиента.СоздатьДокумент();
    Документ.Номер = "000001";
    Документ.Дата = ТекущаяДата();
    Документ.Записать();
    
    ЮТест.ОжидаетЧто(Документ.Ссылка, "Ссылка созданного документа").НеРавно(Неопределено);
  КонецПроцедуры
  
  Процедура Тест_ПроведениеДокумента() Экспорт
    // Создаем новый документ внутри теста
    Документ = Документы.ЗаказКлиента.СоздатьДокумент();
    Документ.Номер = "000002";
    Документ.Дата = ТекущаяДата();
    Документ.Записать(РежимЗаписиДокумента.Проведение);
    
    ЮТест.ОжидаетЧто(Документ.Проведен, "Документ проведен").ЭтоИстина();
  КонецПроцедуры
  ```
  :::

* **Приоритизация:** сначала покрывайте критически важные модули и методы (например, финансовые расчеты), затем — часто изменяемый код или код с историей ошибок

  :::bad
  ```bsl
  // Случайный выбор модулей для тестирования без учета приоритетов
  // Например, покрытие тестами вспомогательного модуля печати штрихкодов,
  // но отсутствие тестов для модуля расчета налогообложения
  ```
  :::

  :::good
  ```bsl
  // Выбор тестов на основе важности и рисков
  
  // Критичный финансовый модуль - высокий приоритет тестирования
  Процедура Тест_РасчетНалоговыхОтчислений() Экспорт
    // Тесты для критически важного модуля
  КонецПроцедуры
  
  // Модуль с частыми изменениями - средний приоритет
  Процедура Тест_ФормированиеОтчетов() Экспорт
    // Тесты для часто меняющегося модуля
  КонецПроцедуры
  
  // Вспомогательный модуль - низкий приоритет
  Процедура Тест_ПечатьШтрихкодов() Экспорт
    // Тесты для вспомогательного модуля
  КонецПроцедуры
  ```
  :::

### Работа с ошибками

* **Анализ падений:** при сбое теста тщательно определяйте причину — это ошибка в коде или в самом тесте? У вас не должно быть периодически падающих тестов, это снижает доверие к системе тестирования

  :::bad
  ```bsl
  // Игнорирование падающего теста
  // @НеСтабильный
  Процедура Тест_СложныйСценарий() Экспорт
    // Код теста, который иногда падает, иногда проходит
    // "Ну, он иногда падает, потом разберемся..."
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Анализ и устранение причины нестабильности
  // Комментарий: Тест был нестабилен из-за зависимости от текущей даты.
  // Причина устранена путем фиксации даты в тесте.
  Процедура Тест_РасчетПериодаДействияДоговора() Экспорт
    // Фиксируем текущую дату для стабильности теста
    ТекущаяДатаВТесте = Дата(2023, 1, 15);
    
    Договор = СоздатьТестовыйДоговор(ТекущаяДатаВТесте);
    ПериодДействия = Договор.РассчитатьПериодДействия(ТекущаяДатаВТесте);
    
    ЮТест.ОжидаетЧто(ПериодДействия, "Период действия договора").Равно(365);
  КонецПроцедуры
  ```

* **Тесты на баги:** воспроизводите найденные ошибки в тестах — воспользуйтесь тестами для воспроизведения выявленного бага, после исправления тест проверит ваши изменения и предотвратит повторное появление ошибки

  :::bad
  ```bsl
  // Исправление бага без создания теста
  // Ошибка: при заполнении табличной части номенклатуры с ценой 0 
  // документ давал неверную общую сумму
  // Разработчик просто исправил код, но не добавил тест
  ```
  :::

  :::good
  ```bsl
  // Тест воспроизводит ранее найденную ошибку
  // Ошибка в задаче №12345: при добавлении в документ номенклатуры 
  // с нулевой ценой итоговая сумма документа рассчитывалась неверно
  Процедура Тест_РасчетСуммыДокументаПриНулевыхЦенах() Экспорт
    Документ = СоздатьТестовыйДокумент();
    
    // Добавляем позицию с нулевой ценой
    СтрокаТЧ = Документ.Товары.Добавить();
    СтрокаТЧ.Номенклатура = СоздатьТестовуюНоменклатуру();
    СтрокаТЧ.Количество = 10;
    СтрокаТЧ.Цена = 0;
    
    // Добавляем обычную позицию
    СтрокаТЧ = Документ.Товары.Добавить();
    СтрокаТЧ.Номенклатура = СоздатьТестовуюНоменклатуру("2");
    СтрокаТЧ.Количество = 5;
    СтрокаТЧ.Цена = 100;
    
    // Рассчитываем итоги
    Документ.РассчитатьИтоги();
    
    // Проверяем, что сумма верна (только 5 * 100 = 500, нулевые цены не влияют)
    ЮТест.ОжидаетЧто(Документ.Сумма, "Сумма документа").Равно(500);
  КонецПроцедуры
  ```
  :::

### Базовые принципы качественных тестов

* **Тестируйте публичный интерфейс, а не внутреннюю реализацию** — не пишите тесты на приватные методы или детали реализации, это увеличивает хрупкость тестов. Фокусируйтесь на том, что делает система, а не на том, как она это делает

  :::bad
  ```bsl
  // Тестирование внутренней реализации
  Процедура Тест_ВнутреннегоМетодаПроверкиКорректностиИНН() Экспорт
    Контрагент = СоздатьКонтрагента(Новый Структура("ИНН", "1234567890"));
    // Прямой вызов закрытого метода модуля
    Результат = ОбщийМодуль.ПриватныйМетод_ПроверитьКорректностьИНН(Контрагент);
    
    ЮТест.ОжидаетЧто(Результат.Корректен, "ИНН корректен").ЭтоИстина();
    ЮТест.ОжидаетЧто(Результат.ТипИНН, "Тип ИНН").Равно("ФизЛицо");
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Тестирование публичного интерфейса
  Процедура Тест_ПроверкиКорректностиИНН() Экспорт
    Контрагент = СоздатьКонтрагента(Новый Структура("ИНН", "1234567890"));
    // Вызов публичного метода, который внутри использует приватную логику
    Результат = ОбщийМодуль.ПроверитьКонтрагента(Контрагент);
    
    ЮТест.ОжидаетЧто(Результат.ИННКорректен, "ИНН корректен").ЭтоИстина();
  КонецПроцедуры
  
  // Если логика приватного метода критична и его нужно протестировать отдельно,
  // рассмотрите возможность сделать его публичным или тестировать через 
  // публичные методы, которые его используют
  ```

* **Структурируйте тесты по принципу AAA (Arrange-Act-Assert):**
  1. Подготовка данных (Arrange) — создание необходимых объектов и настройка тестового окружения
  2. Выполнение действия (Act) — вызов тестируемого метода или функции
  3. Проверка результата (Assert) — проверка полученного результата на соответствие ожидаемому

  :::bad
  ```bsl
  // Смешивание этапов теста и отсутствие структуры
  Процедура Тест_БеспорядочныйМетод() Экспорт
    Клиент = Справочники.Контрагенты.СоздатьЭлемент();
    
    // Проверка сразу после создания
    ЮТест.ОжидаетЧто(Клиент.Наименование, "Наименование клиента").Равно("");
    
    Клиент.Наименование = "Тестовый клиент";
    Клиент.ИНН = "1234567890";
    
    // Вызов функции в середине теста
    Результат = УчетныйМодуль.РассчитатьСкидку(Клиент.Ссылка);
    
    // Еще немного подготовки данных
    ТестоваяДата = ТекущаяДата();
    ЮТест.ОжидаетЧто(Результат.Скидка).Равно(5);
    
    // И снова действие
    Клиент.Записать();
  КонецПроцедуры
  ```
  :::

  :::good
  ```bsl
  // Чёткое разделение на этапы AAA
  Процедура Тест_РасчетСкидкиНовогоКлиента() Экспорт
    // Arrange - Подготовка данных
    Клиент = Справочники.Контрагенты.СоздатьЭлемент();
    Клиент.Наименование = "Тестовый клиент";
    Клиент.ИНН = "1234567890";
    Клиент.КатегорияКлиента = Перечисления.КатегорииКлиентов.Новый;
    Клиент.Записать();
    
    // Act - Выполнение действия
    Результат = УчетныйМодуль.РассчитатьСкидку(Клиент.Ссылка);
    
    // Assert - Проверка результата
    ЮТест.ОжидаетЧто(Результат)
      .Свойство("Скидка").Равно(5)
      .Свойство("Описание").Равно("Скидка для нового клиента");
  КонецПроцедуры
  ```
  :::

## Интеграция тестирования в процесс разработки

Модульные тесты — не дополнительная нагрузка или обременительная обязанность, а неотъемлемая часть процесса разработки, повышающая качество кода и упрощающая его поддержку. Чем меньше разрыв между написанием кода и его тестированием, тем стабильнее система. Следуйте принципу «Написал метод — напиши тест», и вы заметите, насколько проще станет поддерживать и развивать ваш код в долгосрочной перспективе.

### Проблемы отложенного тестирования

Отделение этапа тестирования от разработки приводит к серьезным проблемам:

* **Накопление технического долга:** тесты пишутся в спешке перед релизом или вообще пропускаются "до лучших времен"

  :::bad
  ```
  // План разработки:
  // 1. Реализовать все требуемые функции
  // 2. Если останется время, написать тесты перед релизом
  // 3. В крайнем случае, выпустить без тестов и добавить их потом
  ```
  :::

  :::good
  ```
  // План разработки:
  // 1. Реализовать функцию расчета стоимости доставки + написать тесты на эту функцию
  // 2. Реализовать функцию выбора доступных способов доставки + написать тесты
  // 3. Реализовать интерфейс выбора доставки + написать тесты
  ```
  :::

* **Рост стоимости исправления ошибок:** чем позже обнаружены ошибки, тем сложнее и дороже их исправлять

  :::bad
  ```
  // Схема работы с ошибками:
  // 1. Разработка функциональности (без тестов)
  // 2. Выпуск релиза
  // 3. Обнаружение ошибки в промышленной эксплуатации
  // 4. Срочное исправление ошибки
  // 5. Выпуск патча
  ```
  :::

  :::good
  ```
  // Схема работы с ошибками:
  // 1. Разработка функциональности с сопутствующими тестами
  // 2. Выявление ошибок на этапе тестирования
  // 3. Исправление ошибок до выпуска релиза
  // 4. Выпуск проверенного релиза
  ```
  :::

* **Потеря контекста:** спустя время разработчику сложно вспомнить все нюансы работы кода, что затрудняет создание качественных тестов

  :::bad
  ```
  // Разработка в январе:
  // - Реализован сложный алгоритм расчета бонусов клиентов
  
  // Тестирование в марте:
  // - "Как это работало? Почему здесь такая формула?"
  // - Потеря времени на изучение собственного кода
  // - Возможное упущение важных сценариев тестирования
  ```
  :::

  :::good
  ```
  // Разработка и тестирование в связке:
  // - Реализован метод расчета бонусов
  // - Сразу написаны тесты на основные сценарии, граничные условия
  // - Тесты документируют поведение системы
  ```
  :::

### Решение — параллельное тестирование

* **Тесты как часть задачи:** включайте написание тестов в оценку времени на задачу
  * Пример: Задача «Реализовать расчет бонуса для клиента» — 2 часа на разработку + 1 час на тесты

  :::bad
  ```
  // Оценка задачи в трекере:
  // Задача: Разработать функционал расчета бонусов
  // Оценка: 8 часов
  // (Подразумевается только время на кодирование функционала)
  ```
  :::

  :::good
  ```
  // Оценка задачи в трекере:
  // Задача: Разработать функционал расчета бонусов
  // Оценка: 10 часов
  // Декомпозиция:
  // - Анализ требований: 1 час
  // - Разработка кода: 6 часов
  // - Разработка тестов: 2 часа
  // - Рефакторинг: 1 час
  ```
  :::

* **Немедленное тестирование:** создавайте тесты сразу после (или даже до) написания кода, не ждите, пока накопится большой объем нетестированного кода
  * Пример: реализовали метод РассчитатьСумму() → сразу пишите Тест_РассчитатьСумму()

  :::bad
  ```
  // Подход к разработке:
  // 1. Понедельник: разработка метода РассчитатьСумму()
  // 2. Вторник: разработка метода ПрименитьСкидку()
  // 3. Среда: разработка метода РассчитатьНДС()
  // 4. Четверг: разработка метода СформироватьПечатнуюФорму()
  // 5. Пятница: "О, надо бы тесты написать на всё, что сделали за неделю..."
  ```
  :::

  :::good
  ```
  // Подход к разработке:
  // 1. Понедельник утро: разработка метода РассчитатьСумму()
  // 1. Понедельник день: написание тестов для РассчитатьСумму()
  // 2. Вторник утро: разработка метода ПрименитьСкидку()
  // 2. Вторник день: написание тестов для ПрименитьСкидку()
  // И так далее...
  ```
  :::

* **TDD для ключевой логики:** для важных компонентов сначала пишите тест, определяющий требуемое поведение, а потом код, реализующий это поведение

  :::bad
  ```
  // Традиционный подход:
  // 1. Написать алгоритм расчета налоговых отчислений
  // 2. Проверить вручную на нескольких примерах
  // 3. Может быть, написать тесты позже
  ```
  :::

  :::good
  ```bsl
  // Подход TDD:
  // 1. Написать тест, определяющий, как должен работать метод расчета:
  Процедура Тест_РасчетНДФЛДляРезидентов() Экспорт
    Сотрудник = Справочники.Сотрудники.СоздатьЭлемент();
    Сотрудник.Резидент = Истина;
    Сотрудник.Записать();
    
    НалоговыйРасчет = НалоговыйУчет.РассчитатьНДФЛ(Сотрудник, 100000);
    
    ЮТест.ОжидаетЧто(НалоговыйРасчет.Ставка, 13);
    ЮТест.ОжидаетЧто(НалоговыйРасчет.СуммаНалога, 13000);
  КонецПроцедуры
  
  // 2. Реализовать метод, чтобы тест проходил
  // 3. Рефакторинг и оптимизация с постоянной проверкой теста
  ```
  :::

### Преимущества подхода

* **Раннее обнаружение ошибок:** баги выявляются сразу в процессе разработки, а не на этапе приемки или в промышленной эксплуатации

  **Пример:**
  ```bsl
  // Разработка функции и тестов одновременно:
  
  // 1. Написали функцию расчета налога:
  Функция РассчитатьНалог(Доход)
    Возврат Доход * 0.13;
  КонецФункции
  
  // 2. Написали тест:
  Процедура Тест_РасчетНалога() Экспорт
    Результат = РассчитатьНалог(10000);
    ЮТест.ОжидаетЧто(Результат, 1300);
    
    // Дополнительная проверка на граничные значения
    Результат = РассчитатьНалог(0);
    ЮТест.ОжидаетЧто(Результат, 0);
    
    // Проверка работы с отрицательными значениями (обнаружен потенциальный баг!)
    Результат = РассчитатьНалог(-1000);
    ЮТест.ОжидаетЧто(Результат, 0); // Тест упадет!
  КонецПроцедуры
  
  // 3. Исправили функцию до выпуска:
  Функция РассчитатьНалог(Доход)
    Если Доход <= 0 Тогда
        Возврат 0;
    КонецЕсли;
    Возврат Доход * 0.13;
  КонецФункции
  ```

* **Тесты как документация:** по тестам легко понять, как должен работать код и какие сценарии он поддерживает

  **Пример:**
  ```bsl
  // Тесты наглядно показывают, как использовать модуль и что ожидать:
  
  Процедура Тест_РасчетДоставкиВРегионыРФ() Экспорт
    // По этому тесту видно, что:
    // - Для расчета нужно указать вес, регион и тип доставки
    // - Для Москвы есть специальные тарифы
    // - Есть бесплатная доставка от определенной суммы
    
    Доставка = Новый РасчетДоставки();
    Доставка.Вес = 2.5;
    Доставка.Регион = "Москва";
    Доставка.ТипДоставки = Перечисления.ТипыДоставки.Курьер;
    Доставка.СуммаЗаказа = 3000;
    
    Стоимость = Доставка.Рассчитать();
    ЮТест.ОжидаетЧто(Стоимость, 250);
    
    // Бесплатная доставка от 5000
    Доставка.СуммаЗаказа = 5500;
    Стоимость = Доставка.Рассчитать();
    ЮТест.ОжидаетЧто(Стоимость, 0);
  КонецПроцедуры
  ```

* **Снижение стресса при релизах:** не нужно в спешке "догонять" тесты перед выпуском, все уже проверено

  **Пример:**
  ```
  // План выпуска релиза при практике регулярного тестирования:
  
  // 1. Завершение разработки функционала (с тестами)
  // 2. Подготовка релизных документов и описания изменений
  // 3. Выпуск релиза
  
  // Вместо более стрессового:
  
  // 1. Завершение разработки функционала
  // 2. Авральное написание тестов в последний момент
  // 3. Обнаружение ошибок при тестировании
  // 4. Срочное исправление ошибок
  // 5. Повторное тестирование
  // 6. Задержка релиза
  ```
