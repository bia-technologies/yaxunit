# Рекомендации

Модульные тесты — это инструмент разработчика, улучшающий качество работы.

* Модульные тесты — это код.
* Тесты идут совместно с доработками (при использовании git).
* Быстрый ответ на изменения.
* Высокая скорость реализации и, соответственно, низкая стоимость. На проверку небольшой функции уходит всего несколько секунд. Изолированность юнитов позволяет проверять работоспособность нескольких модулей одновременно.
* Простота автоматизации. Unit-тест исследует ответ кода на ввод данных и определенные действия. Он не требует проиграть сценарий взаимодействия конечного пользователя с новой функцией, поэтому автоматизация процесса не отнимает много сил и времени.

На больших и сложных проектах стопроцентного покрытия кода тестами достичь сложно. К тому же, это нерационально. Показатель 70–90% считается хорошим. Он позволяет выявить максимальное количество ошибок. Мы собрали несколько практических советов по увеличению процента покрытия кода:

* Пишите unit-тест на каждый новый код сразу же.
* Используйте готовые решения – тестовые фреймворки.
* Создавайте тесты для проверки только одной функции.
* Используйте негативные тесты для проверки поведения программы в случае ввода неправильных данных.
* Используйте мутационные фреймворки с функцией изменения констант и условий для проверки качества unit-тестов.
* Проверяйте тесты на стабильность.
* Следите за скоростью выполнения теста.

## Рекомендации по модульному тестированию с использованием YAxUnit

Кроме [общих рекомендаций](common-recommendations.md), обратите внимание на следующие положения:

### Структура тестовых модулей

* Модуль тестового набора должен соответствовать объекту решения, который он будет тестировать. Для этого мы предлагаем [схему наименования модулей](../getting-started/structure.md#схема-наименования-модулей).

### Соблюдайте стандарты

Основная документация YAxUnit предлагает четкие правила организации тестов — используйте их как основу. Например:

* Для каждого проверяемого объекта создавайте отдельный модуль.
* Придерживайтесь правил именования модулей.
* Используйте встроенные инструменты вроде ЮТУтверждения для проверок и конструкторы для создания тестовых данных.

### Используйте изолированное окружение

* **Тестовая база:** Запускайте тесты на «пустышке» или демо-базе без реальных данных. Это исключит побочные эффекты.
* **Очистка данных:** Удаляйте тестовые данные после выполнения. Используйте механизмы движка ВТранзакции и УдалениеТестовыхДанных.
* **Моки и стабы:** Подменяйте внешние сервисы или сложные компоненты, чтобы тесты не зависели от внешних систем.

### Делайте тесты простыми и атомарными

* **Один тест — один сценарий.** Например, вместо общего теста на проводки лучше создать отдельные тесты для проверки различных сценариев.
* **Избегайте ветвления.** Условия (Если) усложняют понимание теста. Если нужны разные сценарии, разбейте их на отдельные методы.

### Параметризуйте тесты

* Один тест может проверять несколько сценариев с разными входными данными.

### Не дублируйте код, но и не усложняйте

* Выносите повторяющиеся действия в отдельные методы (например, создание тестового документа).
* Избегайте излишней абстракции: если вспомогательный метод становится сложным, упростите его.

### Проверяйте не только положительные сценарии

* **Тестируйте обработку ошибок.** Например, как система реагирует на некорректные входные данные.
* **Различные граничные значения:** Минимальные/максимальные числа, отрицательные числа, пустые строки, нулевые даты, пустые ссылки.
* **Проверяйте работу с некорректными данными,** если это необходимо.

### Документируйте тесты

* Добавляйте комментарии, объясняющие цель теста.

### Избегайте зависимостей между тестами

* Каждый тест должен работать независимо от других. Не рассчитывайте, что один тест подготовит данные для другого.

### Пишите тесты на критически важный функционал

* Сначала покрывайте критически важные модули и методы (например, финансовые расчеты).
* Затем — часто изменяемый код или код с историей ошибок.

### Учитесь на ошибках

* **Анализируйте проваленные тесты:**
  * Если тест сломался, проверьте: это ошибка в коде или в самом тесте?
  * У вас не должно быть периодически падающих тестов, это снижает доверие к ним.
* **Добавляйте тесты на найденные баги:**
  * Воспользуйтесь тестами для воспроизведения найденного бага. После исправления он проверит ваши изменения.

### Правило «Тестируйте публичный интерфейс»

* Не пишите тесты на приватные методы или внутреннюю реализацию — это увеличивает хрупкость тестов.
* Фокусируйтесь на том, что делает система, а не как она это делает.

### Используйте принцип AAA (Arrange-Act-Assert)

Структурируйте каждый тест так:

1. Подготовка данных (Arrange).
2. Выполнение действия (Act).
3. Проверка результата (Assert).

## Пишите тесты параллельно с кодом — не откладывайте на потом

### Проблема

Отделение этапа тестирования от разработки приводит к:

* ❌ Накоплению «технического долга»: тесты пишутся в спешке или вообще пропускаются.
* ❌ Росту стоимости исправлений: ошибки обнаруживаются поздно, их сложнее исправлять.
* ❌ Потере контекста: спустя время сложно вспомнить, как должен работать код.

### Решение

Интегрируйте написание тестов в процесс разработки:

#### Тесты как часть задачи

* Включайте создание тестов в оценку времени на задачу.
* **Пример:**
  * Задача: «Реализовать расчет бонуса для клиента».
  * Время: 2 часа на код + 1 час на тесты.

#### Пишите тесты сразу после (или до) кода

* Не ждите, пока накопится 100500 строк кода.
* **Пример подхода:**
  * Реализовали метод РассчитатьСумму() → сразу напишите Тест_РассчитатьСумму().

#### Используйте TDD, где это уместно

* Для ключевой логики сначала напишите тест, потом код.

### Преимущества подхода

* ✔️ Раннее обнаружение ошибок: Баги выявляются сразу, а не на этапе приемки.
* ✔️ Тесты как документация: По тестам легко понять, как работает код.
* ✔️ Снижение стресса: Не нужно «догонять» тесты перед релизом.

Тесты — это не «дополнительная нагрузка», а часть кода. Чем меньше разрыв между разработкой и тестированием, тем стабильнее система. Начните с простого правила: «Написал метод — напиши тест», и вы удивитесь, насколько проще станет поддерживать код.